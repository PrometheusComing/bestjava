package com.best.java.programma;

/**
 * @Author: xjxu3
 * @Date: 2020/6/2 23:26
 * @Description: 0/1背包问题
 * <p>
 * 包的可承载重量是20，问怎么装能让最终总价值最高？（每个物品最多放一件，并不重复）
 * 编号	重量（w）	价值（v）
 * 1	  2	      3
 * 2	  3	      4
 * 3	  4	      5
 * 4	  5	      8
 * 5	  9	      10
 */
public class KnapsackProblem {
	public static void main(String[] args) {
		// 对应各个物品的重量
		int[] w = {0, 2, 3, 4, 5, 9};
		// 对应各个物品的价值
		int[] v = {0, 3, 4, 5, 8, 10};
		int N = 6, W = 21;
		// 注意，每件物品最多只能拿一次，要么拿要么不拿
		// 设定b[k][w]表示有前k件物品可以选择，背包剩余容量为w时，可以获取的最高价值
		// 如b[5][20]表示前5件物品可以选择（本题就是全部可以选择），背包剩余容量为20时，可以获取的最高价值，也就是本题的结果。
		// b[4][20]表示前4件物品可以选择（第5件不能选择），背包剩余容量为20时，可以获取的最高价值
		// 所以b[5][20]的关键在于第五件物品是否入背包，如果入背包，b[5][20]就等于b[4][20-9] + 10，如果不入背包，则
		// b[5][20]等于b[4][20],当然，如果第五件物品的重量超出了背包剩余空间，也是不入背包的情况。
		// 所以b[5][20] = max{b[4][11] + 10,b[4][20]}.
		// 同理，b[4][20] = max{b[3][15] + 8,b[3][20]};b[4][11] = max{b[3][6] + 8,b[3][11]};以此类推
		// 状态转移方程为b[k][w] = max{b[k-1][w-w[k]] + v[k],b[k-1][w]}
		// 根据动态规划的特性，一般都要先计算前面的，再循环到最后要的结果，所以先算好b[0][0],b[0][1]这些基本情况
		// 再慢慢推算后续结果
		// 最好对应二维表格的内容进行考虑，把二维表格尽量画出来一点
		int[][] b = new int[N][W];
		// 外循环，就是物品数量的增加
		for (int k = 1; k < N; k++) {
			// 当有k件物品可以选择时，每个容量对应的最高价值，b[k][c]的值，暂存到数组
			for (int c = 1; c < W; c++) {
				// 重量超出了剩余重量
				if (w[k] > c) {
					b[k][c] = b[k - 1][c];
				} else {
					int value1 = b[k - 1][c - w[k]] + v[k]; // 拿第k件物品
					int value2 = b[k - 1][c]; // 不拿第k件物品
					b[k][c] = Math.max(value1, value2);
				}
			}
		}
		System.out.println(b[5][20]);
	}
}
